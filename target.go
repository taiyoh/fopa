package fopa

import (
	"bytes"
	"fmt"
)

// Target represents code generation target.
type Target struct {
	file *file
	ast  *syntaxTree
}

// FindTarget provides Target object from supplied filename and type definition.
func FindTarget(base, basedir, filename string) (*Target, error) {
	file, err := findFile(basedir, filename)
	if err != nil {
		return nil, err
	}
	if file == nil {
		return nil, nil
	}
	astf, err := file.Ast()
	if err != nil {
		return nil, err
	}

	synTree, err := findAst(base, astf)
	if err != nil {
		return nil, err
	}
	return &Target{
		file: file,
		ast:  synTree,
	}, nil
}

// Build returns generated go code.
func (t *Target) Build(pkgname, factory, builder string) []byte {
	b := bytes.NewBuffer([]byte{})
	fmt.Fprintf(b, `// Code generated by fopa. DO NOT EDIT.`)
	fmt.Fprint(b, "\n\n")
	fmt.Fprintf(b, "package %s\n\n", pkgname)

	ast := t.ast
	objName := ast.Name()
	if imports := ast.ImportPaths(); len(imports) > 0 {
		fmt.Fprint(b, "import (\n")
		for _, i := range imports {
			fmt.Fprintf(b, "\t%s\n", i.String())
		}
		fmt.Fprint(b, ")\n\n")
	}

	fmt.Fprintf(b, "type %s func(*%s)\n\n", builder, objName)

	fmt.Fprintf(b, "func (f *%s) Setup%s(fns ...%s) *%s {\n", factory, ast.TitleName(), builder, objName)
	fmt.Fprintf(b, "\to := &%s{}\n", objName)
	fmt.Fprint(b, "\tfor _, fn := range fns {\n")
	fmt.Fprint(b, "\t\tfn(o)\n")
	fmt.Fprint(b, "\t}\n")
	fmt.Fprint(b, "\treturn o\n")
	fmt.Fprint(b, "}\n")

	for _, f := range ast.fields {
		if !f.tag.enabled {
			continue
		}
		fmt.Fprintf(b, "\nfunc (f *%s) Fill%s(%s) %s {\n", factory, f.titleName(), f.args(), builder)
		fmt.Fprintf(b, "\treturn func(p *%s) {\n", ast.name)
		fmt.Fprintf(b, "\t\tp.%s = %s\n", f.name, f.expr())
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "}\n")
	}

	return b.Bytes()
}

// GeneratedPath returns place for generated code.
func (t *Target) GeneratedPath(factory string) string {
	return t.file.GeneratedPath(factory)
}
