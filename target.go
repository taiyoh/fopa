package fopa

import (
	"bytes"
	"fmt"
	"unicode"
)

// Target represents code generation target.
type Target struct {
	file *File
	ast  *syntaxTree
}

// FindTarget provides Target object from supplied filename and type definition.
func FindTarget(base, basedir, filename string) (*Target, error) {
	file, err := findFile(basedir, filename)
	if file == nil {
		return nil, err
	}
	astf, err := file.AST()
	if err != nil {
		return nil, err
	}

	synTree, err := findAst(base, astf)
	if err != nil {
		return nil, err
	}
	return &Target{
		file: file,
		ast:  synTree,
	}, nil
}

// Build returns generated go code.
func (t *Target) Build(pkgname, factory, builder string) *File {
	b := bytes.NewBuffer([]byte{})

	t.printHeader(b, pkgname)
	t.printImport(b)
	t.printType(b, builder)
	t.printSetup(b, factory, builder)
	t.printFields(b, factory, builder)

	file := t.file
	return &File{
		baseDir:  file.baseDir,
		filename: fmt.Sprintf("%s_gen.go", toSnake(factory)),
		data:     b.Bytes(),
	}
}

func toSnake(in string) string {
	runes := []rune(in)
	length := len(runes)

	var out []rune
	for i := 0; i < length; i++ {
		if i > 0 && unicode.IsUpper(runes[i]) && ((i+1 < length && unicode.IsLower(runes[i+1])) || unicode.IsLower(runes[i-1])) {
			out = append(out, '_')
		}
		out = append(out, unicode.ToLower(runes[i]))
	}

	return string(out)
}

func (t *Target) printHeader(b *bytes.Buffer, pkgname string) {
	fmt.Fprintf(b, "// Code generated by fopa. DO NOT EDIT.\n\n")
	fmt.Fprintf(b, "package %s\n\n", pkgname)
}

func (t *Target) printImport(b *bytes.Buffer) {
	imports := t.ast.ImportPaths()
	if len(imports) < 1 {
		return
	}
	fmt.Fprint(b, "import (\n")
	for _, i := range imports {
		fmt.Fprintf(b, "\t%s\n", i.String())
	}
	fmt.Fprint(b, ")\n\n")
}

func (t *Target) printType(b *bytes.Buffer, builder string) {
	ast := t.ast
	fmt.Fprintf(b, "type %s func(*%s)\n\n", builder, ast.Name())
}

func (t *Target) printSetup(b *bytes.Buffer, factory, builder string) {
	ast := t.ast
	objName := ast.Name()
	fmt.Fprintf(b, "func (f *%s) Setup%s(fns ...%s) *%s {\n", factory, ast.TitleName(), builder, objName)
	fmt.Fprintf(b, "\to := &%s{}\n", objName)
	fmt.Fprint(b, "\tfor _, fn := range fns {\n")
	fmt.Fprint(b, "\t\tfn(o)\n")
	fmt.Fprint(b, "\t}\n")
	fmt.Fprint(b, "\treturn o\n")
	fmt.Fprint(b, "}\n")
}

func (t *Target) printFields(b *bytes.Buffer, factory, builder string) {
	ast := t.ast
	for _, f := range ast.fields {
		if !f.tag.enabled {
			continue
		}
		fmt.Fprintf(b, "\nfunc (f *%s) Fill%s(%s) %s {\n", factory, f.titleName(), f.args(), builder)
		fmt.Fprintf(b, "\treturn func(p *%s) {\n", ast.Name())
		fmt.Fprintf(b, "\t\tp.%s = %s\n", f.name, f.expr())
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "}\n")
	}
}
