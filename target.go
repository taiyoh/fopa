package fopa

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"io/ioutil"
	"strings"

	"golang.org/x/tools/go/loader"
)

// Target represents code generation target.
type Target struct {
	file   string
	name   string
	fields []field
}

// FindTarget provides Target object from supplied filename and type definition.
func FindTarget(base, basedir, filename string) (*Target, error) {
	found := findpath(basedir, filename)
	if found == "" {
		return nil, nil
	}
	data, err := ioutil.ReadFile(found)
	if err != nil {
		return nil, err
	}
	loader := loader.Config{ParserMode: parser.ParseComments}
	astf, err := loader.ParseFile(filename, string(data))
	if err != nil {
		return nil, err
	}
	baseTyp, exists := astf.Scope.Objects[base]
	if !exists {
		return nil, fmt.Errorf("type:%s not found", base)
	}

	typeSpec := baseTyp.Decl.(*ast.TypeSpec).Type.(*ast.StructType)
	fields := []field{}
	for _, f := range typeSpec.Fields.List {
		fields = append(fields, newField(f))
	}

	return &Target{
		file:   found,
		name:   baseTyp.Name,
		fields: fields,
	}, nil
}

// Build returns generated go code.
func (t *Target) Build(pkgname, factory, builder string) []byte {
	b := bytes.NewBuffer([]byte{})
	fmt.Fprintf(b, `// Code generated by fopa. DO NOT EDIT.`)
	fmt.Fprint(b, "\n\n")
	fmt.Fprintf(b, "package %s\n\n", pkgname)

	imports := t.imports()
	if len(imports) > 0 {
		fmt.Fprint(b, "import (\n")
		for _, i := range imports {
			fmt.Fprint(b, "\t")
			fmt.Fprintf(b, `"%s"`, i)
			fmt.Fprint(b, "\n")
		}
		fmt.Fprint(b, ")\n\n")
	}

	fmt.Fprintf(b, "type %s func(*%s)\n\n", builder, t.name)

	fmt.Fprintf(b, "func (f *%s) Setup%s(fns ...%s) *%s {\n", factory, strings.Title(t.name), builder, t.name)
	fmt.Fprintf(b, "\to := &%s{}\n", t.name)
	fmt.Fprint(b, "\tfor _, fn := range fns {\n")
	fmt.Fprint(b, "\t\tfn(o)\n")
	fmt.Fprint(b, "\t}\n")
	fmt.Fprint(b, "\treturn o\n")
	fmt.Fprint(b, "}\n")

	for _, f := range t.fields {
		if !f.tag.enabled {
			continue
		}
		fmt.Fprintf(b, "\nfunc (f *%s) Fill%s(%s) %s {\n", factory, f.titleName(), f.args(), builder)
		fmt.Fprintf(b, "\treturn func(p *%s) {\n", t.name)
		fmt.Fprintf(b, "\t\tp.%s = %s\n", f.name, f.expr())
		fmt.Fprintf(b, "\t}\n")
		fmt.Fprintf(b, "}\n")
	}

	return b.Bytes()
}

// GeneratedPath returns place for generated code.
func (t *Target) GeneratedPath() string {
	return strings.Replace(t.file, ".go", "_gen.go", 1)
}

func (t *Target) imports() []string {
	imports := []string{}
	uniq := map[string]struct{}{}
	for _, f := range t.fields {
		if f.importPkg == "" {
			continue
		}
		if _, ok := uniq[f.importPkg]; ok {
			continue
		}
		imports = append(imports, f.importPkg)
		uniq[f.importPkg] = struct{}{}
	}
	return imports
}
